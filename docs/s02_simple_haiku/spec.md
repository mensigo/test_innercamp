
# Общее

- агент пишет сообщения в stdout (короткие, визуально симпатичные) и в лог (подробные, для отладки)
- на каждом шаге есть свой лог префикс, который добавляется в начало каждого лог-сообщения в рамках шага (напр., `[main]`)
- по ходу диалога все сообщения собираются и доступны в едином списке (истории сообщений)
- ...

todo длина сообщения, усечение
todo timeout=30
todo retries ?

# Запросы на LLM API

## 1. Запрос на генерацию /chat/completions

Отдельная функция: `post_chat_completions(payload: dict, verbose: bool = False) -> dict`

- `payload` обязательно содержит `messages`, может содержать доп. параметры (напр., `temperature`)
- если `payload` не содержит `model`, то устанавливается дефолтное значение `config.default_model` 
- если `verbose=True`, то в лог пишется `payload` (до запроса) и `response` (после успешного запроса) на уровне debug
- если при запросе происходит ошибка, то в лог пишется стектрейс ошибки на уровне critical и возвращается словарь вида `{"error": "<exception text>"}`
- если запрос проходит успешно, возвращается стандартный ответ вида [result_chatcomp.json](../../meta/gigachat/result_chatcomp.json)

## 2. Запрос на эмбеддинги /embeddings

Отдельная функция: `post_embeddings(payload: dict, verbose: bool = False) -> dict`

- `payload` обязательно содержит `input`
- если `payload` не содержит `model`, то устанавливается дефолтное значение `config.default_embedding_model` 
- если `verbose=True`, то в лог пишется `payload` (до запроса) и `response` (после успешного запроса) на уровне debug
- если при запросе происходит ошибка, то в лог пишется стектрейс ошибки на уровне critical и возвращается словарь вида `{"error": "< exception text >"}`
- если запрос проходит успешно, возвращается стандартный ответ вида [result_embeddings.json](../../meta/gigachat/result_embeddings.json)


# Основной сценарий

## Шаг 1. Запрос на агента.

Лог префикс: `[main]` 

1. Начало работы.

Если сессия только началась, то агент пишет справочное сообщение в stdout и статус "AgentStart" в лог (debug).
Иначе агент пишет только статус "AgentRestart" в лог (debug).

2. Агент запрашивает ввод от пользователя.

Если ввод содержит команду из списка `config.exit_commands`, то агент выводит "До свидания!" в stdout, пишет "AgentEnd" в лог (debug) и завершает выполнение.

Если ввод содержит команду из списка `config.help_commands`, то агент выводит справочное сообщение в stdout, пишет "AgentHelp" в лог (debug) и запрашивает ввод еще раз.

Получив сообщение от пользователя, агент добавляет его в историю сообщений.


## Шаг 2. Классификация интента

Лог префикс: `[cls]`

1. Агент пишет "Анализирую релевантность запроса.." в stdout и статус "AgentClassify" в лог (debug).

2. Агент анализирует историю сообщений и с помощью запроса на LLM определяет, относится ли интент пользователя к данному агенту.

Если запрос падает с ошибкой, то агент:
  - пишет "Ошибка при запросе LLM, завершаюсь.." в stdout
  - пишет "classify_intent // LLM Error: < error text >" в лог (critical)
  - завершает выполнение

Если произошла ошибка при парсинге ответа LLM, то агент:
  - пишет "Ошибка при разборе ответа LLM, завершаюсь.." в stdout
  - пишет "classify_intent // LLM Response Parse Error: < error text >" в лог (critical)
  - завершает выполнение

Если ответ обработан успешно, и запрос пользователя **не** соответствует функционалу агента, то агент:
  - пишет "Запрос не связан с функционалом агента." в stdout и добавляет в историю сообщений
  - выводит справочное сообщение в stdout
  - пишет "classify_intent // Irrelevant query" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)

Если ответ обработан успешно, и запрос пользователя соответствует функционалу агента, то агент:
  - пишет "Запрос релевантен, думаю.." в stdout и добавляет в историю сообщений
  - пишет "classify_intent // Relevant query" в лог (debug)
  - проходит на Шаг 3


## Шаг 3. Выбор инструмента

Лог префикс: `[select]`

1. Агент пишет "Выбираю подходящий инструмент.." в stdout и статус "AgentSelect" в лог (debug).

2. Агент анализирует историю сообщений и с помощью запроса на LLM определяет, какой инструмент необходимо вызвать с какими параметрами.

Если запрос падает с ошибкой, то агент:
  - пишет "Ошибка при запросе LLM, завершаюсь.." в stdout
  - пишет "select_tool_call // LLM Error: < error text >" в лог (critical)
  - завершает выполнение

Если произошла ошибка при парсинге ответа LLM, то агент:
  - пишет "Ошибка при разборе ответа LLM, завершаюсь.." в stdout
  - пишет "select_tool_call // LLM Response Parse Error: < error text >" в лог (critical)
  - завершает выполнение

Если ответ обработан успешно, и **не** удалось определить инструмент, то агент:
  - пишет "Не удалось определить инструмент. Просьба переформулировать запрос." в stdout и добавляет в историю сообщений
  - пишет "select_tool_call // Selection Fail" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)

Если ответ обработан успешно, и удалось определить инструмент, то агент:
  - пишет "Выбран инструмент < название > с параметрами < параметры, значения >" в stdout и добавляет в историю сообщений
  - пишет "select_tool_call // Selection OK" в лог (debug)
  - проходит на Шаг 4


## Шаг 4. Валидация инструмента

Лог префикс: `[valid]`

1. Агент пишет "Валидирую инструмент.." в stdout и статус "AgentValidate" в лог (debug).

2. Агент проверяет выбранный инструмент и извлеченные параметры.

2.1 Пусть это инструмент `rag_search`.

Если параметр `question` отсутствует, то агент:
  - пишет "Не совсем понял вопрос. Просьба переформулировать." в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Missing Param: rag_search::question" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)

Если параметр `question` пустой, то агент:
  - пишет "Не совсем понял вопрос. Просьба переформулировать." в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Empty Param: rag_search::question" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)

Если параметр `question` превышает `config.param_question_maxlen` символов, то агент:
  - пишет "Вопрос слишком длинный. Просьба сформулировать более кратко." в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Too Long Param: rag_search::question" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)

Иначе агент:
  - пишет "Инструмент rag_search проверен и готов к вызову. Запрос: < question >" в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Validation OK" в лог (debug)
  - проходит на Шаг 5
 
2.2 Пусть это инструмент `generate_haiku`.

Если параметр `theme` отсутствует, то агент:
  - пишет "Не совсем понял вопрос. Просьба переформулировать." в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Missing Param: generate_haiku::theme" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)

Если параметр `theme` пустой, то агент:
  - пишет "Не совсем понял вопрос. Просьба переформулировать." в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Empty Param: generate_haiku::theme" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)

Если параметр `theme` превышает `config.PARAM_THEME_MAXLEN` символов, то агент:
  - пишет "Тема слишком длинная. Просьба сформулировать более кратко." в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Too Long Param: generate_haiku::theme" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)

Иначе агент:
  - пишет "Инструмент generate_haiku проверен и готов к вызову. Тема: < theme >" в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Validation OK" в лог (debug)
  - проходит на Шаг 5

2.3 Неизвестный инструмент (не должен происходить):
  - пишет "Не удалось провалидировать запрос. Просьба переформулировать." в stdout и добавляет в историю сообщений
  - пишет "validate_tool_call // Unknown tool: < name >" в лог (warning)
  - проходит на Шаг 1 (запрос ввода от пользователя)


## Шаг 5. Выполнение инструмента

Лог префикс: `[exec]`

1. Агент пишет "Выполняю инструмент.." в stdout и статус "AgentExecute" в лог (debug).

2. Агент выполняет выбранный инструмент, показывает результат пользователю.

2.1 Пусть это инструмент `rag_search`.

Агент осуществляет запрос на RAG сервис /search с параметром `question` и `top_k` (по умолчанию `config.param_rag_top_k`).

2.1.1 Ошибка при запросе / в ответе

Если при выполнении запроса произошла ошибка, то агент:
- пишет "Произошла чудовищная ошибка при запросе на RAG сервис.. Тысяча извинений! Попробуем снова?" в stdout и добавляет в историю сообщений
- пишет доп. сообщения в зависимости от ситуации (подробнее ниже)
- проходит на Шаг 1 (запрос ввода от пользователя)

Дополнительно в зависимости от ситуации:
- если ошибка при выполнении запроса /health, агент пишет:
  - "check_health // Unexpected error: < error text >" в лог (error)
  - "answer_question // Health check failed" в лог (error)

- если ошибка в успешном ответе /health (status != ok), агент пишет "answer_question // Health check failed" в лог (error)
 
- если ошибка при выполнении запроса /search, агент пишет "answer_question // Unexpected error: < error text >" в лог (error)
- если ошибка в успешном ответе /search (есть поле "error"), агент пишет "answer_question // Search error: < error text >" в лог (error)

2.1.2 Успешный запрос

Если запрос /search успешный, то агент получает следующие данные:
  ```yaml
  answer:
    type: string
    description: ответ по RAG
  
  chunk_title_list:
    type: array
    items:
      type: string
    description: заголовки топ чанков
  
  chunk_texts:
    type: array
    items:
      type: string
    description: тексты топ чанков
  ```

Дополнительно агент:
- пишет "Ответ RAG: < rag answer >" в stdout и добавляет в историю сообщений
- пишет "Заголовки топ-< top_k > документов: < chunk titles, comma separated >" в stdout
- пишет "rag_chunks_message: < chunks' content, arbitrary format, visually decent >" в лог (debug)
- проходит на Шаг 1 (запрос ввода от пользователя)


2.2 Пусть это инструмент `generate_haiku`.

Агент осуществляет запрос на Haiku сервис /generate_haiku с параметром `theme`.

2.2.1 Ошибка при запросе / в ответе

Если при выполнении запроса произошла ошибка, то агент:
- пишет "Произошла чудовищная ошибка при генерации хайку.. Тысяча извинений! Попробуем снова?" в stdout и добавляет в историю сообщений
- пишет доп. сообщения в зависимости от ситуации (подробнее ниже)
- проходит на Шаг 1 (запрос ввода от пользователя)

Дополнительно в зависимости от ситуации:
- если ошибка при выполнении запроса /health, агент пишет:
  - "check_health // Unexpected error: < error text >" в лог (error)
  - "generate_haiku // Health check failed" в лог (error)

- если ошибка в успешном ответе /health (status != ok), агент пишет "generate_haiku // Health check failed" в лог (error)
 
- если ошибка при выполнении запроса /generate_haiku, агент пишет "generate_haiku // Unexpected error: < error text >" в лог (error)
- если ошибка в успешном ответе /generate_haiku (есть поле "error"), агент пишет "generate_haiku // Generation error: < error text >" в лог (error)

2.2.2 Успешный запрос

Если запрос /generate_haiku успешный, то агент получает следующие данные:
  ```yaml
  haiku_text:
    type: string
    description: текст хайку
  
  syllables_per_line:
    type: array
    items:
      type: integer
    description: число слогов по строкам хайку
  
  total_words:
    type: integer
    description: общее число слов в хайку
  ```

Дополнительно агент:
- пишет "Хайку: < haiku text, pipe separated >" в stdout и добавляет в историю сообщений
- пишет "#слогов построчно: < total_words >" в stdout
- пишет "#слов итого: < syllables_per_line, '-' separated >" в stdout
- проходит на Шаг 1 (запрос ввода от пользователя)



## Config

| param                   | value                                         | description                          |
|:------------------------|:----------------------------------------------|:-------------------------------------|
| EXIT_COMMANDS           | {'/exit', '/quit', '/q', 'exit', 'quit', 'q'} | Команды для выхода                   |
| HELP_COMMANDS           | {'/help', 'help', '?'}                        | Команды для справки                  |
| DEFAULT_MODEL           | GigaChat-2-Max                                | Дефолтная модель для генерации       |
| DEFAULT_EMBEDDING_MODEL | Embeddings                                    | Дефолтная модель для эмбеддингов     |
| CONTEXT_HIST_LIMIT      | 10                                            | Макс. число сообщений в контексте    |
| PARAM_QUESTION_MAXLEN   | 30                                            | Макс. допустимая длина вопроса (rag) |
| PARAM_THEME_MAXLEN      | 20                                            | Макс. допустимая длина темы (haiku)  |
| PARAM_RAG_TOP_K         | 2                                             | Число чанков от RAG                  |




